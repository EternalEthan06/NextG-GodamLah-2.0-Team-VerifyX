<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Modal Verification | SLP-ID</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        body {
            background-color: #0b0f19;
            /* Ultra Dark Navy */
            color: white;
            font-family: 'Segoe UI', Roboto, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow-x: hidden;
            padding: 20px;
        }

        .security-container {
            text-align: center;
            max-width: 600px;
            width: 100%;
            padding: 30px;
        }

        .official-badge {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            opacity: 0.7;
            font-size: 11px;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        h1 {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 5px;
        }

        p {
            color: #94a3b8;
            font-size: 14px;
            margin-bottom: 30px;
        }

        /* --- THE SCANNER HUD --- */
        .scanner-hud {
            width: 320px;
            height: 240px;
            background: #111827;
            border: 2px solid #374151;
            border-radius: 12px;
            margin: 0 auto 25px;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
        }

        /* WEBCAM VIDEO LAYER */
        #webcam {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            /* Mirror effect */
            z-index: 1;
            display: none;
            /* Hidden until started */
        }

        .user-silhouette {
            font-size: 140px;
            color: #1f2937;
            z-index: 0;
        }

        /* --- VISIBLE OVERLAYS ONLY --- */
        .scan-overlay {
            position: absolute;
            pointer-events: none;
            z-index: 5;
            display: none;
        }

        /* 1. Face Grid (Visible Layer) */
        .face-grid {
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: linear-gradient(#0ea5e9 1px, transparent 1px), linear-gradient(90deg, #0ea5e9 1px, transparent 1px);
            background-size: 40px 40px;
            /* Larger grid for camera */
            opacity: 0.2;
        }

        /* 2. Hand Zone (Visible Layer) */
        .hand-zone {
            bottom: 10px;
            right: 10px;
            width: 80px;
            height: 100px;
            border: 2px dashed #fbbf24;
            /* Yellow */
            border-radius: 8px;
            display: none;
            align-items: center;
            justify-content: center;
            color: #fbbf24;
            font-size: 10px;
            text-transform: uppercase;
            background: rgba(251, 191, 36, 0.1);
        }

        /* --- GESTURE CHALLENGE BOX (OVERLAY) --- */
        .gesture-challenge {
            /* position: absolute; REMOVED */
            background: rgba(31, 41, 55, 0.8);
            /* Semi-transparent */
            padding: 10px 20px;
            border-radius: 10px;
            border: 1px solid rgba(55, 65, 81, 0.8);
            display: none;
            /* z-index: 10; REMOVED */
            text-align: center;
            margin: 0 auto 20px;
            /* Center and add gap below */
        }

        .gesture-image {
            width: 60px;
            height: 60px;
            object-fit: contain;
            margin: 5px 0;
            display: block;
            margin-left: auto;
            margin-right: auto;
        }

        .gesture-text {
            font-size: 16px;
            font-weight: bold;
            color: #fbbf24;
            text-transform: uppercase;
        }

        .gesture-sub {
            font-size: 10px;
            color: #e5e7eb;
            margin-bottom: 2px;
        }

        /* --- BUTTONS --- */
        .btn-action {
            background: #0ea5e9;
            color: white;
            border: none;
            padding: 12px 40px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
        }

        .btn-action:hover {
            background: #0284c7;
        }

        .btn-action:disabled {
            background: #4b5563;
            cursor: not-allowed;
        }

        .status-log {
            margin-top: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #0ea5e9;
            min-height: 20px;
        }
    </style>
</head>

<body>

    <div class="security-container">
        <div class="official-badge">
            <img src="https://flagcdn.com/w40/my.png" alt="Malaysia" style="width: 20px; border-radius: 2px;">
            Simultaneous Biometric Gate
        </div>

        <!-- VISIBLE GLOBAL TIMER -->
        <div style="text-align: center; margin-bottom: 15px;">
            <span style="font-size: 14px; color: #94a3b8;">Session expires in:</span>
            <span id="global-timer-display"
                style="font-weight: bold; color: #f59e0b; font-family: monospace; font-size: 16px;">90s</span>
        </div>

        <h1>Identity Verification</h1>
        <p>Hold the gesture while looking at the camera.</p>

        <div class="scanner-hud">
            <video id="webcam" autoplay playsinline></video>

            <i class="fas fa-user user-silhouette"></i>

            <div class="scan-overlay face-grid" id="faceGrid"></div>
            <div class="scan-overlay hand-zone" id="handZone">
                <span id="handStatusText">Analyzing<br>Gesture</span>
            </div>



            <!-- TIMER OVERLAY -->
            <div id="uTimer"
                style="position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.7); color: white; padding: 5px 10px; border-radius: 4px; font-family: monospace; font-size: 14px; display: none; z-index: 10;">
                TIME: <span id="timeRemaining">15</span>
            </div>
        </div>

        <!-- GESTURE CHALLENGE (MOVED HERE) -->
        <div class="gesture-challenge" id="challengeBox">
            <div class="gesture-sub">PERFORM GESTURE:</div>
            <img src="" alt="Gesture" class="gesture-image" id="gestureIconImg">
            <div class="gesture-text" id="gestureName">Open Palm</div>
        </div>

        <button class="btn-action" id="startBtn">
            Start Camera & Scan
        </button>

        <div class="status-log" id="statusLog">System Ready.</div>
    </div>

    <script>
        // --- GLOBAL TIMEOUT: AUTO-REDIRECT ---
        document.addEventListener('DOMContentLoaded', function () {
            const remaining = parseInt("{{ timeout|default(90) }}");

            // Auto Redirect
            if (remaining <= 0) {
                window.location.href = "/login?alert=timeout";
            } else {
                setTimeout(() => {
                    window.location.href = "/login?alert=timeout";
                }, remaining * 1000);
            }

            // Update Visible Global Timer
            startGlobalTimer(remaining);
        });

        function startGlobalTimer(seconds) {
            let sec = Math.floor(seconds);
            const interval = setInterval(() => {
                const el = document.getElementById('global-timer-display');
                if (el) el.innerText = sec + "s";
                sec--;
                if (sec < 0) clearInterval(interval);
            }, 1000);
        }
    </script>
    <script type="module">
        import {
            GestureRecognizer,
            FilesetResolver,
            DrawingUtils
        } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

        // CONFIGURATION
        const GESTURE_DURATION_REQUIRED = 3000; // 3.0s hold duration
        const TIMEOUT_SECONDS = 10;             // 10s timeout (GAME LOGIC)

        // APP STATE
        let gestureRecognizer = undefined;
        let runningMode = "VIDEO";
        let webcamRunning = false;
        let requestedGesture = "";
        let gestureStartTime = 0;
        let isHoldingCorrect = false;
        let timerInterval = null;
        let remainingTime = TIMEOUT_SECONDS;
        let gameActive = false;

        const video = document.getElementById('webcam');
        const startBtn = document.getElementById('startBtn');
        const log = document.getElementById('statusLog');
        const faceGrid = document.getElementById('faceGrid');
        const handZone = document.getElementById('handZone');
        const handStatusText = document.getElementById('handStatusText');
        const challengeBox = document.getElementById('challengeBox');
        const timerUI = document.getElementById('uTimer');
        const timeSpan = document.getElementById('timeRemaining');

        // MAPPING: UI Name -> MediaPipe Category OR Custom Logic
        // Icons: Images from gestures/
        const gesturesData = [
            // Built-in MediaPipe Gestures
            { uiName: "Open Palm", type: "MP", mpName: "Open_Palm", img: "open_palm.png" },
            { uiName: "Closed Fist", type: "MP", mpName: "Closed_Fist", img: "closed_fist.png" },
            { uiName: "Peace Sign", type: "MP", mpName: "Victory", img: "peace.png" },
            { uiName: "Thumbs Up", type: "MP", mpName: "Thumb_Up", img: "thumbs_up.png" },
            { uiName: "Thumbs Down", type: "MP", mpName: "Thumb_Down", img: "thumbs_down.png" },

            { uiName: "Point Up", type: "CUSTOM", mpName: "POINT_UP", img: "point_up.png" },

            // Custom Heuristics
            { uiName: "OK Sign", type: "CUSTOM", mpName: "OK", img: "ok.png" },
            { uiName: "Number Three", type: "CUSTOM", mpName: "THREE", img: "three.png" }, // Index+Mid+Ring
            { uiName: "Number Four", type: "CUSTOM", mpName: "FOUR", img: "four.png" }  // 4 fingers
        ];

        // 1. INITIALIZE MODEL
        const createGestureRecognizer = async () => {
            log.innerText = ">> DOWNLOADING AI MODELS...";
            try {
                const vision = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
                );
                gestureRecognizer = await GestureRecognizer.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath:
                            "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task",
                        delegate: "GPU"
                    },
                    runningMode: runningMode
                });
                log.innerText = ">> SYSTEM READY. CLICK START.";
                startBtn.disabled = false;
                startBtn.addEventListener("click", enableCam);
            } catch (err) {
                console.error(err);
                log.innerText = ">> ERROR LOADING MODEL. CHECK INTERNET.";
                log.style.color = "red";
            }
        };

        // Start loading immediately
        startBtn.disabled = true;
        startBtn.innerText = "Start";
        createGestureRecognizer();


        // 2. ENABLE WEBCAM
        async function enableCam(event) {
            if (!gestureRecognizer) {
                alert("Please wait for gesture recognizer to load");
                return;
            }

            if (webcamRunning === true) {
                webcamRunning = false;
                return;
            }

            // Lock UI
            startBtn.disabled = true;
            startBtn.innerHTML = '<i class="fas fa-circle-notch fa-spin"></i> STARTING...';

            const constraints = { video: true };

            try {
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                video.style.display = "block";

                video.addEventListener("loadeddata", predictWebcam);
                webcamRunning = true;

                startGame();

            } catch (err) {
                console.error(err);
                log.innerText = ">> CAMERA PERMISSION DENIED";
                startBtn.innerText = "Camera Failed";
            }
        }

        // 3. GAME LOGIC
        function startGame() {
            remainingTime = TIMEOUT_SECONDS;
            gameActive = true;
            isHoldingCorrect = false;
            gestureStartTime = 0;

            // UI Updates
            timeSpan.innerText = remainingTime;
            timerUI.style.display = "block";
            timerUI.style.color = "white"; // Reset color
            faceGrid.style.display = "block";
            handZone.style.display = "flex";
            handZone.style.borderColor = "#fbbf24";
            handZone.style.color = "#fbbf24";
            handStatusText.innerHTML = "Scanning...";

            // Pick Gesture
            const randomG = gesturesData[Math.floor(Math.random() * gesturesData.length)];
            requestedGesture = randomG;

            document.getElementById('gestureName').innerText = randomG.uiName;
            // Update Image Source
            document.getElementById('gestureIconImg').src = `/static/images/gestures/${randomG.img}`;

            challengeBox.style.display = "block";

            log.innerText = ">> SHOW THIS: " + randomG.uiName.toUpperCase();

            // Start Timer
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                remainingTime--;
                timeSpan.innerText = remainingTime;

                if (remainingTime <= 3) {
                    timerUI.style.color = "red";
                }

                if (remainingTime <= 0) {
                    endGame(false);
                }
            }, 1000);
        }

        async function endGame(success) {
            gameActive = false;
            clearInterval(timerInterval);
            // Don't stop webcam yet, we might need to retry or capture frame
            // webcamRunning = false; 

            if (success) {
                log.innerText = ">> GESTURE CORRECT. VERIFYING IDENTITY...";
                log.style.color = "#fbbf24";
                handZone.innerHTML = "<i class='fas fa-spinner fa-spin'></i>";

                // DATA CAPTURE
                const canvas = document.createElement('canvas');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

                canvas.toBlob((blob) => {
                    const formData = new FormData();
                    formData.append('image', blob, 'gesture_verify.jpg');

                    fetch('/verify-gesture-identity', {
                        method: 'POST',
                        body: formData
                    })
                        .then(response => response.json())
                        .then(data => {
                            if (data.status === 'success') {
                                // SUCCESS -> Show Green
                                log.innerText = ">> IDENTITY MATCHED. BLINK CHECK PASSED.";
                                log.style.color = "#10b981";
                                handZone.style.borderColor = "#10b981";
                                handZone.style.color = "#10b981";
                                handZone.innerHTML = "<i class='fas fa-check'></i>";

                                setTimeout(() => {
                                    window.location.href = "/step-complete";
                                }, 1000);
                            } else {
                                // FAILURE (Identity or Timeout)
                                log.innerText = ">> VERIFICATION FAILED: " + data.message.toUpperCase();
                                log.style.color = "red";
                                handZone.style.borderColor = "red";
                                handZone.innerHTML = "<i class='fas fa-user-times'></i>";

                                startBtn.innerText = "Retry Verification";
                                startBtn.disabled = false;
                                startBtn.onclick = () => location.reload();
                            }
                        })
                        .catch(err => {
                            console.error(err);
                            log.innerText = ">> SERVER ERROR during Identity Check.";
                            log.style.color = "red";
                        });
                }, 'image/jpeg');

            } else {
                // TIMEOUT FAILURE
                webcamRunning = false; // Stop cam on timeout
                log.innerText = ">> GESTURE FAILED: TIMEOUT";
                log.style.color = "red";
                handZone.style.borderColor = "red";
                handZone.innerHTML = "<i class='fas fa-times'></i>";

                startBtn.innerText = "Retry Scan";
                startBtn.disabled = false;
                startBtn.onclick = () => location.reload();
            }
        }


        // 4. PREDICTION LOOP
        async function predictWebcam() {
            if (!gameActive) return;

            let nowInMs = Date.now();

            if (video.currentTime !== video.lastVideoTime) {
                video.lastVideoTime = video.currentTime;

                const results = gestureRecognizer.recognizeForVideo(video, nowInMs);

                let foundMatch = false;

                if (results.gestures.length > 0) {
                    const topGesture = results.gestures[0][0];
                    const categoryName = topGesture.categoryName;
                    const score = topGesture.score;
                    const landmarks = results.landmarks[0]; // array of 21 points

                    // DEBUG
                    // console.log(`MP Category: ${categoryName}, Score: ${score}`);

                    if (requestedGesture.type === "MP") {
                        // Standard MP Check
                        if (categoryName === requestedGesture.mpName && score > 0.5) {
                            foundMatch = true;
                        }
                    } else if (requestedGesture.type === "CUSTOM" && landmarks) {
                        // Custom Landmark Check
                        if (checkCustomGesture(landmarks, requestedGesture.mpName)) {
                            foundMatch = true;
                        }
                    }
                }

                // Handle Match Result
                if (foundMatch) {
                    if (!isHoldingCorrect) {
                        isHoldingCorrect = true;
                        gestureStartTime = nowInMs;
                        handZone.style.backgroundColor = "rgba(16, 185, 129, 0.2)"; // Green tint
                        handStatusText.innerText = "Hold Still...";
                    } else {
                        // Check duration
                        const heldTime = nowInMs - gestureStartTime;
                        const progress = Math.min((heldTime / GESTURE_DURATION_REQUIRED) * 100, 100);
                        handStatusText.innerText = `Holding... ${Math.floor(progress)}%`;

                        // SUCCESS!
                        if (heldTime > GESTURE_DURATION_REQUIRED) {
                            endGame(true);
                            return;
                        }
                    }
                } else {
                    // Lost match
                    isHoldingCorrect = false;
                    handZone.style.backgroundColor = "rgba(251, 191, 36, 0.1)"; // Default yellow
                    handStatusText.innerText = "Analyzing...";
                }
            }

            if (webcamRunning === true) {
                window.requestAnimationFrame(predictWebcam);
            }
        }

        // 5. CUSTOM GESTURE HELPER
        function checkCustomGesture(landmarks, type) {
            // Landmarks: 0-20. 
            // 4=ThumbTip, 8=IndexTip, 12=MidTip, 16=RingTip, 20=PinkyTip
            // 0=Wrist

            // Helper: Is finger extended? (Tip y < PIP y) - Note: y increases downwards in canvas usually
            // but MP-task values are normalized. 0 is top.
            const isFingerUp = (tipIdx, pipIdx) => {
                return landmarks[tipIdx].y < landmarks[pipIdx].y;
            };

            const thumbUp = isFingerUp(4, 3); // Simple check
            const indexUp = isFingerUp(8, 6);
            const midUp = isFingerUp(12, 10);
            const ringUp = isFingerUp(16, 14);
            const pinkyUp = isFingerUp(20, 18);

            // Distance helper
            const getDist = (i1, i2) => {
                const dx = landmarks[i1].x - landmarks[i2].x;
                const dy = landmarks[i1].y - landmarks[i2].y;
                return Math.sqrt(dx * dx + dy * dy);
            };

            if (type === "OK") {
                // OK: Thumb and Index tips close. Mid/Ring/Pinky UP.
                // Note: Thumb can be tricky. Let's check distance between 4 and 8.
                const distThumbIndex = getDist(4, 8);
                // Thresholds are empirical.
                return (distThumbIndex < 0.1) && midUp && ringUp && pinkyUp;
            }

            if (type === "THREE") {
                // Three: Index, Mid, Ring UP. Pinky DOWN.
                return indexUp && midUp && ringUp && !pinkyUp;
            }

            if (type === "FOUR") {
                // Four: Index, Mid, Ring, Pinky UP. Thumb tucked or arbitrary?
                // Usually just 4 fingers up.
                return indexUp && midUp && ringUp && pinkyUp;
            }

            if (type === "POINT_UP") {
                // Point Up: Index UP. Others DOWN.
                // Strict check: Index extended, others curled.
                return indexUp && !midUp && !ringUp && !pinkyUp;
            }

            return false;
        }
    </script>
</body>

</html>